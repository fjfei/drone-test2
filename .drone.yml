
kind: pipeline
type: docker # 在 Docker Runner 中运行
name: default

# 定义步骤 Steps，每个 step 有属于自己 name，最后显示在 Drone CI 管理页面的侧边栏，代表每一步的名字。
steps:
- name: restore-cache # 把之前缓存好的数据取出
  image: drillster/drone-volume-cache
  settings:
    restore: true
    mount: # 缓存挂载的文件夹
      - ./.npm-cache
      - ./node_modules
  volumes:
    - name: cache
      path: /cache

- name: install # 安装依赖
  image: 172.17.0.2:5000/nodejs # 使用了本地Registry的nodejs，加快拉取速度
  commands:
    - npm config set cache ./.npm-cache --global 
    - npm i --production --registry=https://registry.npm.taobao.org 
# 不用npm ci，因为 npm ci 会先把 node_modules 文件夹移除，如果非要用 npm ci 可以把 restore-cache 和 rebuild-cache 这两个 step 去掉。

- name: test
  image: 172.17.0.2:5000/nodejs
  commands:
    - npm test

- name: build # 将程序打包成 Docker，放到私有 Docker 仓库中
  image: plugins/docker
  settings:
    insecure: true # 因为使用的是私有仓库，没有 https 支持，所以要设置成 insecure 才能连接
    dockerfile: Dockerfile # 使用 Dockerfile 的名字
    username:
      from_secret: account # 声明 username 从 Secret 为 account 的值中取出，在Drone的控制面板里可以设置，后面Q&A中介绍Secret
    password:
      from_secret: registry_password
    repo: 172.17.0.2:5000/backendsample # 打包后 Docker 镜像的名字
    registry: 172.17.0.2:5000 # 私有镜像仓库的地址

- name: rebuild-cache # 把依赖和 npm 缓存放到缓存里
  image: drillster/drone-volume-cache
  settings:
    rebuild: true
    mount:
      - ./.npm-cache
      - ./node_modules
  volumes:
    - name: cache
      path: /cache
# when 定义的是运行此 step 的条件
  when: # 只在事件为 push，分支为 master 而且上一步成功的时候运行
    branch:
      - master
    event:
      - push
    status:
      - success

- name: deploy # 用SSH连接到宿主机器运行部署命令
  image: appleboy/drone-ssh
  settings:
    host: xxxx.com
    username:
      from_secret: account
    password:
      from_secret: account_password
    port: 22
    command_timeout: 30m # ssh命令行执行超时时间，30分钟
    script_stop: false # 设置为false，遇到第一次错误会继续运行后面的命令
    # script定义的是所要运行的command
    script:
      - sudo docker pull 172.17.0.2:5000/backendsample # 拉取backendsample的新镜像
      - sudo docker stop backendsample && sudo docker rm backendsample # 停止并删除旧容器
      - sudo docker run --name backendsample --network redis_network --network-alias server_network -d -p 7001:7001 172.17.0.2:5000/backendsample # 从新镜像中建立容器并运行
      - sudo docker image prune -f --filter "dangling=true" # 清除无用的镜像
  when:
    branch:
      - master
    event:
      - push
    status:
      - success

- name: notify # 用了Server酱的webhook微信通知部署消息
  image: plugins/webhook
  settings:
    urls:
      from_secret: notify_url
    content_type: application/x-www-form-urlencoded
    template: |
      text=自动部署{{ build.status }}了&desp=在{{ repo.name }}的{{build.branch}}上{{ build.event }}了{{truncate build.commit 8}}的commit, 结果 `{{ build.status }}` 了, 耗时{{ since build.started }}, 点这里[查询]({{ build.link }})
    headers: origin=https://xxxx.com
    debug: true
  when: # 无论成功失败都运行
    status:
      - failure
      - success

# 私有镜像仓库的密钥在后面填坑里详细解释
# image_pull_secrets:
# - dockerconfig

# 声明并挂载缓存文件夹，宿主机的路径为 /tmp/cache
volumes:
- name: cache
  host:
    path: /tmp/cache

# 运行一个redis服务，在npm test测试时可以作为测试环境，语法与docker-compose类似。
services:
  - name: redis
    image: 172.17.0.2:5000/redis
    ports:
      - 6379
